CASL	START	BEGIN
BEGIN	LAD	GR6, 0
	LAD	GR7, OUTBUF
	JUMP	MAIN
MAIN	NOP
;;;start assign;;;
	LAD	GR1, VAR1	; left var address (global) 
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, 8	; int
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
;;;start assign;;;
	LAD	GR1, 1	; int
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR9	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, 96	; int
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
;;;start assign;;;
	LAD	GR1, 1	; int
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR10	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, 86	; int
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
;;;start assign;;;
	LAD	GR1, 2	; int
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR9	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, 89	; int
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
;;;start assign;;;
	LAD	GR1, 2	; int
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR10	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, 56	; int
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
;;;start assign;;;
	LAD	GR1, 3	; int
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR9	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, 78	; int
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
;;;start assign;;;
	LAD	GR1, 3	; int
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR10	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, 81	; int
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
;;;start assign;;;
	LAD	GR1, 4	; int
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR9	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, 68	; int
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
;;;start assign;;;
	LAD	GR1, 4	; int
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR10	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, 86	; int
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
;;;start assign;;;
	LAD	GR1, 5	; int
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR9	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, 58	; int
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
;;;start assign;;;
	LAD	GR1, 5	; int
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR10	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, 78	; int
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
;;;start assign;;;
	LAD	GR1, 6	; int
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR9	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, 49	; int
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
;;;start assign;;;
	LAD	GR1, 6	; int
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR10	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, 56	; int
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
;;;start assign;;;
	LAD	GR1, 7	; int
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR9	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, 39	; int
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
;;;start assign;;;
	LAD	GR1, 7	; int
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR10	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, 23	; int
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
;;;start assign;;;
	LAD	GR1, 8	; int
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR9	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, 32	; int
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
;;;start assign;;;
	LAD	GR1, 8	; int
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR10	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, 24	; int
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
;;;start assign;;;
	LAD	GR1, VAR0	; left var address (global) 
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, 1	; int
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
;;;start assign;;;
	LAD	GR1, VAR2	; left var address (global) 
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, 0	; int
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
;;;start assign;;;
	LAD	GR1, VAR3	; left var address (global) 
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, 0	; int
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
;;;start assign;;;
	LAD	GR1, VAR4	; left var address (global) 
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, 0	; int
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
;;;start assign;;;
	LAD	GR1, VAR5	; left var address (global) 
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, 0	; int
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
	LAD	GR1, ST0	; factor1: load GR1(address const 'No. x    y    xy     x^2') 
	PUSH	0, GR1	; equation_array1: push equations
	LAD	GR1, 24	; writeln0: set write length (string)
	LD	GR2, 0, GR8	; writeln1:
	CALL	WRTSTR	; writeln2:
	CALL	WRTLN	; writeln_last
	POP	GR1	; writeln_reset:
BWH0	NOP	; while1: set label for loop
	LAD	GR1, VAR0	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	PUSH	0, GR1	; equation1: save left_operand to stack
	LAD	GR1, VAR1	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	LAD	GR2, 0, GR1	; equation2: mv right_operand to GR2
	POP	GR1	; equation3: restore left_operand to GR1
	LAD	GR3, 0	; eqation: load FALSE to GR3
	CPA	GR1, GR2	; equation: compare
	JPL	ELE2	; equation: JUMP
	LAD	GR3, 1, GR3	; equation: increment
ELE2	LAD	GR1, 0, GR3	 equation_last: save result
	CPL	GR1, GR6	; while3: compare GR1 with FALSE
	JZE	AWH1	; while4: if GR1 FALSE goto label(while 6)
	LAD	GR1, VAR0	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	PUSH	0, GR1	; equation_array1: push equations
	LAD	GR1, ST1	; factor1: load GR1(address const '   ') 
	PUSH	0, GR1	; equation_array1: push equations
	LAD	GR1, VAR0	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR9	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	PUSH	0, GR1	; equation_array1: push equations
	LAD	GR1, ST1	; factor1: load GR1(address const '   ') 
	PUSH	0, GR1	; equation_array1: push equations
	LAD	GR1, VAR0	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR10	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	PUSH	0, GR1	; equation_array1: push equations
	LAD	GR1, ST1	; factor1: load GR1(address const '   ') 
	PUSH	0, GR1	; equation_array1: push equations
	LAD	GR1, VAR0	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR9	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	PUSH	0, GR1	; term1: save left_operand to stack
	LAD	GR1, VAR0	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR10	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	LAD	GR2, 0, GR1	; term2: move right_operand to GR2
	POP	GR1	; term3: restore left_operand
	CALL	MULT	; term4: call submodule
	LAD	GR1, 0, GR2	; term5: move result to GR1
	PUSH	0, GR1	; equation_array1: push equations
	LAD	GR1, ST1	; factor1: load GR1(address const '   ') 
	PUSH	0, GR1	; equation_array1: push equations
	LAD	GR1, VAR0	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR9	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	PUSH	0, GR1	; term1: save left_operand to stack
	LAD	GR1, VAR0	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR9	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	LAD	GR2, 0, GR1	; term2: move right_operand to GR2
	POP	GR1	; term3: restore left_operand
	CALL	MULT	; term4: call submodule
	LAD	GR1, 0, GR2	; term5: move result to GR1
	PUSH	0, GR1	; equation_array1: push equations
	LD	GR2, 8, GR8	; writeln1:
	CALL	WRTINT	; writeln2:
	LAD	GR1, 3	; writeln0: set write length (string)
	LD	GR2, 7, GR8	; writeln1:
	CALL	WRTSTR	; writeln2:
	LD	GR2, 6, GR8	; writeln1:
	CALL	WRTINT	; writeln2:
	LAD	GR1, 3	; writeln0: set write length (string)
	LD	GR2, 5, GR8	; writeln1:
	CALL	WRTSTR	; writeln2:
	LD	GR2, 4, GR8	; writeln1:
	CALL	WRTINT	; writeln2:
	LAD	GR1, 3	; writeln0: set write length (string)
	LD	GR2, 3, GR8	; writeln1:
	CALL	WRTSTR	; writeln2:
	LD	GR2, 2, GR8	; writeln1:
	CALL	WRTINT	; writeln2:
	LAD	GR1, 3	; writeln0: set write length (string)
	LD	GR2, 1, GR8	; writeln1:
	CALL	WRTSTR	; writeln2:
	LD	GR2, 0, GR8	; writeln1:
	CALL	WRTINT	; writeln2:
	CALL	WRTLN	; writeln_last
	POP	GR1	; writeln_reset:
	POP	GR1	; writeln_reset:
	POP	GR1	; writeln_reset:
	POP	GR1	; writeln_reset:
	POP	GR1	; writeln_reset:
	POP	GR1	; writeln_reset:
	POP	GR1	; writeln_reset:
	POP	GR1	; writeln_reset:
	POP	GR1	; writeln_reset:
;;;start assign;;;
	LAD	GR1, VAR2	; left var address (global) 
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, VAR2	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	PUSH	0, GR1	; simple_equation1: save left_operand to stack
	LAD	GR1, VAR0	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR9	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	LAD	GR2, 0, GR1	; simple_equation2: move right_operand to GR2
	POP	GR1	; simple_equation3: restore left_operand
	ADDA	GR1, GR2	; simple_equation3: operate
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
;;;start assign;;;
	LAD	GR1, VAR3	; left var address (global) 
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, VAR3	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	PUSH	0, GR1	; simple_equation1: save left_operand to stack
	LAD	GR1, VAR0	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR10	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	LAD	GR2, 0, GR1	; simple_equation2: move right_operand to GR2
	POP	GR1	; simple_equation3: restore left_operand
	ADDA	GR1, GR2	; simple_equation3: operate
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
;;;start assign;;;
	LAD	GR1, VAR4	; left var address (global) 
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, VAR4	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	PUSH	0, GR1	; simple_equation1: save left_operand to stack
	LAD	GR1, VAR0	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR9	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	PUSH	0, GR1	; term1: save left_operand to stack
	LAD	GR1, VAR0	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR10	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	LAD	GR2, 0, GR1	; term2: move right_operand to GR2
	POP	GR1	; term3: restore left_operand
	CALL	MULT	; term4: call submodule
	LAD	GR1, 0, GR2	; term5: move result to GR1
	LAD	GR2, 0, GR1	; simple_equation2: move right_operand to GR2
	POP	GR1	; simple_equation3: restore left_operand
	ADDA	GR1, GR2	; simple_equation3: operate
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
;;;start assign;;;
	LAD	GR1, VAR5	; left var address (global) 
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, VAR5	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	PUSH	0, GR1	; simple_equation1: save left_operand to stack
	LAD	GR1, VAR0	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR9	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	PUSH	0, GR1	; term1: save left_operand to stack
	LAD	GR1, VAR0	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	LAD	GR2, 1	; var0: load array start index
	CPA	GR1, =1	; var array check index
	JMI	ERROR0	; var array check index
	CPA	GR1, =8	; var array check index
	JPL	ERROR0	; var array check index
	SUBA	GR1, GR2	; var0: adjust subscript
	PUSH	0, GR1	; var1: save subscript
	POP	GR2	; var2: pop subscript to GR2
	LAD	GR1, ARR9	; var3: global variable address
	ADDA	GR1, GR2	; var4: add subscript to base
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	LAD	GR2, 0, GR1	; term2: move right_operand to GR2
	POP	GR1	; term3: restore left_operand
	CALL	MULT	; term4: call submodule
	LAD	GR1, 0, GR2	; term5: move result to GR1
	LAD	GR2, 0, GR1	; simple_equation2: move right_operand to GR2
	POP	GR1	; simple_equation3: restore left_operand
	ADDA	GR1, GR2	; simple_equation3: operate
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
;;;start assign;;;
	LAD	GR1, VAR0	; left var address (global) 
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, VAR0	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	PUSH	0, GR1	; simple_equation1: save left_operand to stack
	LAD	GR1, 1	; int
	LAD	GR2, 0, GR1	; simple_equation2: move right_operand to GR2
	POP	GR1	; simple_equation3: restore left_operand
	ADDA	GR1, GR2	; simple_equation3: operate
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
	JUMP	BWH0	; while5: back loop top
AWH1	NOP	; while6: end while
	CALL	WRTLN	; writeln_last
	LAD	GR1, ST2	; factor1: load GR1(address const 'Sigma(x)=   ') 
	PUSH	0, GR1	; equation_array1: push equations
	LAD	GR1, VAR2	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	PUSH	0, GR1	; equation_array1: push equations
	LAD	GR1, 12	; writeln0: set write length (string)
	LD	GR2, 1, GR8	; writeln1:
	CALL	WRTSTR	; writeln2:
	LD	GR2, 0, GR8	; writeln1:
	CALL	WRTINT	; writeln2:
	CALL	WRTLN	; writeln_last
	POP	GR1	; writeln_reset:
	POP	GR1	; writeln_reset:
	LAD	GR1, ST3	; factor1: load GR1(address const 'Sigma(y)=   ') 
	PUSH	0, GR1	; equation_array1: push equations
	LAD	GR1, VAR3	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	PUSH	0, GR1	; equation_array1: push equations
	LAD	GR1, 12	; writeln0: set write length (string)
	LD	GR2, 1, GR8	; writeln1:
	CALL	WRTSTR	; writeln2:
	LD	GR2, 0, GR8	; writeln1:
	CALL	WRTINT	; writeln2:
	CALL	WRTLN	; writeln_last
	POP	GR1	; writeln_reset:
	POP	GR1	; writeln_reset:
	LAD	GR1, ST4	; factor1: load GR1(address const 'Sigma(xy)=  ') 
	PUSH	0, GR1	; equation_array1: push equations
	LAD	GR1, VAR4	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	PUSH	0, GR1	; equation_array1: push equations
	LAD	GR1, 12	; writeln0: set write length (string)
	LD	GR2, 1, GR8	; writeln1:
	CALL	WRTSTR	; writeln2:
	LD	GR2, 0, GR8	; writeln1:
	CALL	WRTINT	; writeln2:
	CALL	WRTLN	; writeln_last
	POP	GR1	; writeln_reset:
	POP	GR1	; writeln_reset:
	LAD	GR1, ST5	; factor1: load GR1(address const 'Sigma(x^2)= ') 
	PUSH	0, GR1	; equation_array1: push equations
	LAD	GR1, VAR5	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	PUSH	0, GR1	; equation_array1: push equations
	LAD	GR1, 12	; writeln0: set write length (string)
	LD	GR2, 1, GR8	; writeln1:
	CALL	WRTSTR	; writeln2:
	LD	GR2, 0, GR8	; writeln1:
	CALL	WRTINT	; writeln2:
	CALL	WRTLN	; writeln_last
	POP	GR1	; writeln_reset:
	POP	GR1	; writeln_reset:
;;;start assign;;;
	LAD	GR1, VAR6	; left var address (global) 
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, VAR1	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	PUSH	0, GR1	; term1: save left_operand to stack
	LAD	GR1, VAR5	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	LAD	GR2, 0, GR1	; term2: move right_operand to GR2
	POP	GR1	; term3: restore left_operand
	CALL	MULT	; term4: call submodule
	LAD	GR1, 0, GR2	; term5: move result to GR1
	PUSH	0, GR1	; simple_equation1: save left_operand to stack
	LAD	GR1, VAR2	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	PUSH	0, GR1	; term1: save left_operand to stack
	LAD	GR1, VAR2	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	LAD	GR2, 0, GR1	; term2: move right_operand to GR2
	POP	GR1	; term3: restore left_operand
	CALL	MULT	; term4: call submodule
	LAD	GR1, 0, GR2	; term5: move result to GR1
	LAD	GR2, 0, GR1	; simple_equation2: move right_operand to GR2
	POP	GR1	; simple_equation3: restore left_operand
	SUBA	GR1, GR2	; simple_equation3: operate
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
	LAD	GR1, VAR6	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	PUSH	0, GR1	; term1: save left_operand to stack
	LAD	GR1, VAR5	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	LAD	GR2, 0, GR1	; term2: move right_operand to GR2
	POP	GR1	; term3: restore left_operand
	CALL	MULT	; term4: call submodule
	LAD	GR1, 0, GR2	; term5: move result to GR1
	PUSH	0, GR1	; equation1: save left_operand to stack
	LAD	GR1, 0	; int
	LAD	GR2, 0, GR1	; equation2: mv right_operand to GR2
	POP	GR1	; equation3: restore left_operand to GR1
	LAD	GR3, 1	; eqation: load FALSE to GR3
	CPL	GR1, GR2	; equation: compare
	JZE	SEQ3	; equation: JUMP
	LAD	GR3, -1, GR3	; equation: increment
SEQ3	LAD	GR1, 0, GR3	 equation_last: save result
	CPL	GR1, GR6	; if2: compare GR1 with FALSE
	JZE	EIF4	; if3: if GR1 FALSE go to label(else2 or if4)
	LAD	GR1, ST6	; factor1: load GR1(address const 'Fitting Unsuccessful.') 
	PUSH	0, GR1	; equation_array1: push equations
	LAD	GR1, 21	; writeln0: set write length (string)
	LD	GR2, 0, GR8	; writeln1:
	CALL	WRTSTR	; writeln2:
	CALL	WRTLN	; writeln_last
	POP	GR1	; writeln_reset:
	JUMP	ELS5	; else1: go to end if(if4)
EIF4	NOP	; else2: set else label
;;;start assign;;;
	LAD	GR1, VAR8	; left var address (global) 
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, VAR5	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	PUSH	0, GR1	; term1: save left_operand to stack
	LAD	GR1, VAR3	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	LAD	GR2, 0, GR1	; term2: move right_operand to GR2
	POP	GR1	; term3: restore left_operand
	CALL	MULT	; term4: call submodule
	LAD	GR1, 0, GR2	; term5: move result to GR1
	PUSH	0, GR1	; simple_equation1: save left_operand to stack
	LAD	GR1, VAR4	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	PUSH	0, GR1	; term1: save left_operand to stack
	LAD	GR1, VAR2	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	LAD	GR2, 0, GR1	; term2: move right_operand to GR2
	POP	GR1	; term3: restore left_operand
	CALL	MULT	; term4: call submodule
	LAD	GR1, 0, GR2	; term5: move result to GR1
	LAD	GR2, 0, GR1	; simple_equation2: move right_operand to GR2
	POP	GR1	; simple_equation3: restore left_operand
	SUBA	GR1, GR2	; simple_equation3: operate
	PUSH	0, GR1	; term1: save left_operand to stack
	LAD	GR1, VAR6	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	LAD	GR2, 0, GR1	; term2: move right_operand to GR2
	POP	GR1	; term3: restore left_operand
	CALL	DIV	; term4: call submodule
	LAD	GR1, 0, GR2	; term5: move result to GR1
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
;;;start assign;;;
	LAD	GR1, VAR7	; left var address (global) 
	PUSH	0, GR1	; assign_statement1: save lefthand(must absolute address) to stack top
	LAD	GR1, VAR4	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	PUSH	0, GR1	; simple_equation1: save left_operand to stack
	LAD	GR1, VAR8	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	PUSH	0, GR1	; term1: save left_operand to stack
	LAD	GR1, VAR2	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	LAD	GR2, 0, GR1	; term2: move right_operand to GR2
	POP	GR1	; term3: restore left_operand
	CALL	MULT	; term4: call submodule
	LAD	GR1, 0, GR2	; term5: move result to GR1
	LAD	GR2, 0, GR1	; simple_equation2: move right_operand to GR2
	POP	GR1	; simple_equation3: restore left_operand
	SUBA	GR1, GR2	; simple_equation3: operate
	PUSH	0, GR1	; term1: save left_operand to stack
	LAD	GR1, VAR5	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	LAD	GR2, 0, GR1	; term2: move right_operand to GR2
	POP	GR1	; term3: restore left_operand
	CALL	DIV	; term4: call submodule
	LAD	GR1, 0, GR2	; term5: move result to GR1
	LAD	GR2, 0, GR1	; assign_statement2: move GR1(righthand) to GR2
	POP	GR1	; assign_statement3: get stack top(lefthad)
	ST	GR2, 0, GR1	; assign_statement4: store GR2 to GR1
;;;end assign;;;
	CALL	WRTLN	; writeln_last
	LAD	GR1, ST7	; factor1: load GR1(address const 'a=') 
	PUSH	0, GR1	; equation_array1: push equations
	LAD	GR1, VAR7	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	PUSH	0, GR1	; equation_array1: push equations
	LAD	GR1, ST8	; factor1: load GR1(address const '   b=') 
	PUSH	0, GR1	; equation_array1: push equations
	LAD	GR1, VAR8	; left var address (global) 
	LD	GR1, 0, GR1	; factor1: load GR1(address variable) to GR1(value)
	PUSH	0, GR1	; equation_array1: push equations
	LAD	GR1, 2	; writeln0: set write length (string)
	LD	GR2, 3, GR8	; writeln1:
	CALL	WRTSTR	; writeln2:
	LD	GR2, 2, GR8	; writeln1:
	CALL	WRTINT	; writeln2:
	LAD	GR1, 5	; writeln0: set write length (string)
	LD	GR2, 1, GR8	; writeln1:
	CALL	WRTSTR	; writeln2:
	LD	GR2, 0, GR8	; writeln1:
	CALL	WRTINT	; writeln2:
	CALL	WRTLN	; writeln_last
	POP	GR1	; writeln_reset:
	POP	GR1	; writeln_reset:
	POP	GR1	; writeln_reset:
	POP	GR1	; writeln_reset:
ELS5	NOP	; if4: end if
	JUMP	ENDMAIN
ERROR0	LAD	GR2, OOIMES
	LD	GR1, OOILEN
	CALL	WRTSTR
	CALL	WRTLN
	JUMP	ENDMAIN
ERROR1	LAD	GR2, INBMES
	LD	GR1, INBLEN
	CALL	WRTSTR
	CALL	WRTLN
	JUMP	ENDMAIN
ENDMAIN	NOP	; end my MAIN program
	RET	; end my MAIN program
;;;GLOBAL;;;
VAR0	DS	1	; integer,n	0
VAR1	DS	1	; integer,max	0
VAR2	DS	1	; integer,sx	0
VAR3	DS	1	; integer,sy	0
VAR4	DS	1	; integer,sxy	0
VAR5	DS	1	; integer,sx2	0
VAR6	DS	1	; integer,w	0
VAR7	DS	1	; integer,a	0
VAR8	DS	1	; integer,b	0
ARR9	DS	8	; integer, array, dx	0
ARR10	DS	8	; integer, array, dy	0
OUTBUF	DS	256	; for SUBMOJULE
;;;CONST;;;
ST0	DC	'No. x    y    xy     x^2'
ST1	DC	'   '
ST2	DC	'Sigma(x)=   '
ST3	DC	'Sigma(y)=   '
ST4	DC	'Sigma(xy)=  '
ST5	DC	'Sigma(x^2)= '
ST6	DC	'Fitting Unsuccessful.'
ST7	DC	'a='
ST8	DC	'   b='
OOIMES	DC	'error: index out of range'	; 
OOILEN	DC	25	; 
INBMES	DC	'error: input not boolean (true(1) or false(0))'	; 
INBLEN	DC	46	; 
	END	; end my program
;====================
; MULT: 掛け算を行うサブルーチン
; GR1 * GR2 -> GR2
MULT	START
	PUSH	0,GR1 ; GR1 の内容をスタックに退避
	PUSH	0,GR3 ; GR3 の内容をスタックに退避
	PUSH	0,GR4 ; GR4 の内容をスタックに退避
	LAD	GR3,0 ; GR3 を初期化
	LD	GR4,GR2
	JPL	LOOP
	XOR	GR4,=#FFFF
	ADDA	GR4,=1
LOOP	SRL	GR4,1
	JOV	ONE
	JUMP	ZERO
ONE	ADDL	GR3,GR1
ZERO	SLL	GR1,1
	AND	GR4,GR4
	JNZ	LOOP
	CPA	GR2,=0
	JPL	END
	XOR	GR3,=#FFFF
	ADDA	GR3,=1
END	LD	GR2,GR3
	POP	GR4
	POP	GR3
	POP	GR1
	RET
	END
;====================
; DIV 割り算を行うサブルーチン
; GR1 / GR2 -> 商は GR2, 余りは GR1
DIV	START
	PUSH	0, GR3
	ST	GR1, A
	ST	GR2, B
	CPA	GR1, =0
	JPL	SKIPA
	XOR	GR1, =#FFFF
	ADDA	GR1, =1
SKIPA	CPA	GR2, =0
	JZE	SKIPD
	JPL	SKIPB
	XOR	GR2, =#FFFF
	ADDA	GR2, =1
SKIPB	LD	GR3, =0
LOOP	CPA	GR1, GR2
	JMI	STEP
	SUBA	GR1, GR2
	LAD	GR3, 1, GR3
	JUMP	LOOP
STEP	LD	GR2, GR3
	LD	GR3, A
	CPA	GR3, =0
	JPL	SKIPC
	XOR	GR1, =#FFFF
	ADDA	GR1, =1
SKIPC	XOR	GR3, B
	CPA	GR3, =0
        JZE     SKIPD
	JPL	SKIPD
	XOR	GR2, =#FFFF
	ADDA	GR2, =1
SKIPD	POP	GR3
	RET
A	DS	1
B	DS	1
	END
;====================
; 入力装置から数値データを読み込み，
; その内容を GR2 が指すアドレスに格納するサブルーチン
RDINT	START
	PUSH	0,GR1 ; GR1 の内容をスタックに退避
	PUSH	0,GR3 ; GR3 の内容をスタックに退避
	PUSH	0,GR4 ; GR4 の内容をスタックに退避
	PUSH	0,GR5 ; GR5 の内容をスタックに退避
	PUSH	0,GR6 ; GR6 の内容をスタックに退避
	LD	GR5,GR2 ; GR2 が指す番地を GR5 にコピー
	LD	GR2,=0 ; GR2 を初期化
	LD	GR3,=0 ; GR3 を初期化
	IN	INAREA,INLEN ; 入力を受け取る
	; 入力がnullかどうかのチェック
	CPA	GR3,INLEN
	JZE	ERROR
	; 最初の文字が'-'かどうかのチェック
	LD	GR4,INAREA,GR3
	LAD	GR3,1,GR3
	LD	GR6,GR4 ; GR6 に入力された先頭の文字を保存
	CPL	GR4,=#002D ; '-'かどうか
	JZE	LOOP
	CPL	GR4,='0' ; 数値かどうかのチェック
	JMI	ERROR
	CPL	GR4,='9' 
	JPL	ERROR
	XOR	GR4,=#0030 ; 数値だったら変換
	ADDA	GR2,GR4
	; 「すでに読み込んだ数値を10倍して，
	; 新しく読み込んだ数値と足す．」を繰り返す
LOOP	CPA	GR3,INLEN
	JZE	CODE ; 入力された文字数とGR3が同じであればループを抜ける
	LD	GR1,=10
	CALL	MULT ; GR2 の値を10倍する
	LD	GR4,INAREA,GR3
	CPL	GR4,='0' ; 数値かどうかのチェック
	JMI	ERROR
	CPL	GR4,='9' 
	JPL	ERROR
	XOR	GR4,=#0030 ; GR4 の内容を数値に変換
	ADDA	GR2,GR4 ; GR2 に GR1 の内容を足す
	LAD	GR3,1,GR3; GR3 (ポインタ)をインクリメント
	JUMP	LOOP
	; 最初の文字が '-'であった場合は，-1倍する
CODE	CPL	GR6,=#002D
	JNZ	END
	XOR	GR2,=#FFFF
	LAD	GR2,1,GR2
	JUMP	END
	; エラーを出力する
ERROR	OUT	ERRSTR,ERRLEN
END	ST	GR2,0,GR5 ; GR2 の内容を GR5 が指す番地に格納する
	LD	GR2,GR5 ; GR5 が指す番地を GR2 に戻す
	POP	GR6
	POP	GR5
	POP	GR4
	POP	GR3
	POP	GR1
	RET
ERRSTR	DC	'illegal input'
ERRLEN	DC	13
INAREA	DS	6
INLEN	DS	1
	END
;====================
; 入力装置から文字を読み込み，
; その内容を GR2 が指すアドレスに格納するサブルーチン
RDCH	START
	IN	INCHAR,INLEN
	LD	GR1,INCHAR
	ST	GR1,0,GR2
	RET
INCHAR	DS	1
INLEN	DS	1
	END
;====================
; 入力装置から，GR1の文字数を読み込む．
; 読み込んだ文字列は，GR2 が指すアドレスから順に格納される
RDSTR	START
	PUSH	0,GR3 ; GR3 の内容をスタックに退避
	PUSH	0,GR4 ; GR4 の内容をスタックに退避
	PUSH	0,GR5 ; GR5 の内容をスタックに退避
	LAD	GR4,0 ; GR4 を初期化
	IN	INSTR,INLEN
LOOP	CPA	GR4,GR1
	JZE	END ; GR1で指定された文字数を超えたら終わり
	CPA	GR4,INLEN
	JZE	END ; 入力された文字数を超えたら終わり
	LD	GR5,GR2
	ADDA	GR5,GR4 ; 文字の格納先番地を計算
	LD	GR3,INSTR,GR4
	ST	GR3,0,GR5
	LAD	GR4,1,GR4
	JUMP	LOOP
END	POP	GR5
	POP	GR4
	POP	GR3
	RET
INSTR	DS	256
INLEN	DS	1
	END
;====================
; 入力装置からの文字列を改行まで読み飛ばすサブルーチン
RDLN	START
	IN	INAREA,INLEN
	RET
INAREA	DS	256
INLEN	DS	1
	END
;====================
; GR2 の内容（数値データ）を出力装置に書き出すサブルーチン
; このサブルーチンが呼ばれたとき，
; GR7 には，出力用番地の先頭アドレスが，
; GR6 には，現在出力用番地に入っている文字数が，
; それぞれ格納されている．
WRTINT  START
	PUSH    0,GR1 ; GR1の内容をスタックに退避
        PUSH    0,GR2 ; GR2の内容をスタックに退避
	PUSH	0,GR3 ; GR3の内容をスタックに退避
	PUSH	0,GR2 ; 数値データをもう一度スタックに退避
	LD	GR3,=0 ; GR3 はインデックスとして用いる
	; 数値データが負数である場合は，正の数に変換
	CPA	GR2,=0
	JPL	LOOP1
	XOR	GR2,=#FFFF
	ADDA	GR2,=1
	; 数値データを変換しながら，バッファに格納
LOOP1	LD	GR1,GR2
	LD	GR2,=10
	CALL	DIV
	XOR	GR1,=#0030
	ST	GR1,BUFFER,GR3
	LAD	GR3,1,GR3
	CPA	GR2,=0
	JNZ	LOOP1
	; 数値データが負数であれば，'-'を追加
	POP	GR2
	CPA	GR2,=0
	JZE	LOOP2
	JPL	LOOP2
	LD	GR1,='-'
	ST	GR1,BUFFER,GR3
	LAD	GR3,1,GR3
	; BUFFER を逆順にたどりながら，出力用バッファに格納
LOOP2	LAD	GR3,-1,GR3
	LD	GR1,BUFFER,GR3
	LD	GR2,GR7
	ADDA	GR2,GR6
	ST	GR1,0,GR2
	LAD	GR6,1,GR6
	CPA	GR3,=0
	JNZ	LOOP2
END	POP	GR3
	POP	GR2
	POP	GR1
	RET
BUFFER	DS	6	
	END
;====================
; GR2 の内容（文字）を出力装置に書き出すサブルーチン
; このサブルーチンが呼ばれたとき，
; GR7 には，出力用番地の先頭アドレスが，
; GR6 には，現在出力用番地に入っている文字数が，
; それぞれ格納されている．
WRTCH	START
	PUSH	0,GR1 ; GR1 の内容をスタックに退避
	LD	GR1,GR7
	ADDA	GR1,GR6 ; GR1 に次の文字を格納する番地を代入
	ST	GR2,0,GR1
	LAD	GR6,1,GR6
	POP	GR1
	RET
	END
;====================
; GR2 の指すメモリ番地から，長さ GR1 の文字列を出力装置に書き出すサブルーチン
; このサブルーチンが呼ばれたとき，
; GR7 には，出力用番地の先頭アドレスが，
; GR6 には，現在出力用番地に入っている文字数が，
; それぞれ格納されている．
WRTSTR	START
	PUSH	0,GR3 ; GR3 の内容をスタックに退避
	PUSH	0,GR4 ; GR4 の内容をスタックに退避
	PUSH	0,GR5 ; GR5 の内容をスタックに退避
	LAD	GR3, 0 ; GR3 は制御変数として用いる
LOOP	CPA	GR3,GR1
	JZE	END
	LD	GR4,GR2
	ADDA	GR4,GR3 ; 出力する文字の格納番地を計算
	LD	GR5,0,GR4 ; 出力する文字をレジスタにコピー
	LD	GR4,GR7
	ADDA	GR4,GR6 ; 出力先の番地を計算
	ST	GR5,0,GR4 ; 出力装置に書き出し
	LAD	GR3,1,GR3
	LAD	GR6,1,GR6
	JUMP	LOOP
END	POP	GR5
	POP	GR4
	POP	GR3
	RET
	END
;====================
; 改行を出力装置に書き出すサブルーチン
; 実質的には，GR7で始まるアドレス番地から長さGR6の文字列を出力する
WRTLN	START
	PUSH	0,GR1
	PUSH	0,GR2
	PUSH	0,GR3
	ST	GR6,OUTLEN
	LAD	GR1,0
LOOP	CPA	GR1,OUTLEN
	JZE	END
	LD	GR2,GR7
	ADDA	GR2,GR1
	LD	GR3,0,GR2
	ST	GR3,OUTSTR,GR1
	LAD	GR1,1,GR1
	JUMP	LOOP	
END	OUT	OUTSTR,OUTLEN
	LAD	GR6,0 ; 文字列を出力して，GR6 を初期化
	POP	GR3
	POP	GR2
	POP	GR1
	RET
OUTSTR	DS	256
OUTLEN	DS	1
	END
