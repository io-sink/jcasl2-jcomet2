# JCasl2 & JComet2

[JCasl2 & JComet2](https://github.com/kusumotolab/jcasl2-jcomet2)を改造し，実行された命令数だけでなく，より詳しい情報を出力するようにしています．

## 概要
**JCasl2 & JComet2**は`-c`オプションを与えると，終了後に実行された命令数を出力しますが，より詳しい情報が欲しくなる時があります．

例えばレジスタ割り付けの工夫は，変数を主記憶に置くよりもレジスタに置く方がアクセス時間が短くなることを前提にして行われるので，全ての命令の実行コストを1とする命令数によって評価するのは必ずしも正確ではありません．

ここでは，最適化の効果を正確に評価するために，「言語処理工学」の講義とそのテキスト[1]で使われているモデルを採用して，実行された命令のコストの合計を計測する機能を追加しました．

### 評価方法
主記憶の1語分の領域にアクセスするごとにコスト1を加算します．
ここで，命令のフェッチでも命令の語数分のコストが発生することに注意が必要です．以下に，機械語命令とコストの例を示します．

|機械語命令|命令の語数|コスト
|-|-|-|
|LD r1, r1|1|1|
|LD r1, adr, x|2|3|
|ST r1, adr, x|2|3|
|LAD r1, adr, x|2|2|
|ADDA r1, r2|1|1|
|ADDA r1, adr, x|2|3|
|SLA r, adr, x|2|2|
|JPL adr, x|2|2|
|JUMP adr, x|2|2|
|PUSH adr, x|2|3|
|POP r|1|2|
|RPUSH|1|9|
|RPOP|1|9|
|CALL adr, x|2|3|
|RET|1|2|
|SVC adr, x|2|2|
|NOP|1|1|
|IN|3|4(下の注意を参照)|
|OUT|3|4(下の注意を参照)|

### 入出力命令について
CASL2の仕様ではIN，OUT命令はマクロ命令であり，アセンブラによってSVC命令などに展開されることになっています．
しかし**JCasl2 & JComet2**では，IN，OUT命令は内部的には機械語命令で，機械語(0x9000, 0x9100)と一対一対応します．

本来であれば入出力の長さに依存したコストを設定すべきですが，COMET2を実計算機として見た場合に入出力命令がどのように実現されているか仮定することが難しいこと，入出力命令について最適化を行うことは考えにくいことから，一律にコスト4としました．

### 即値命令について
この評価方法を実装するときに問題となるのは，即値命令の存在です．
CASL2では，メモリのアドレスを指定する演算命令のオペランドに`"=" + 定数`を指定することで，レジスタと即値との演算命令とすることができます．

例えば，`ADD GR1, =1`という命令はフェッチ以外にメモリを参照する必要がないので，コスト2(2語命令のフェッチのみ)とするべきです．
しかしCOMET2はレジスタと即値の演算命令を持たないため，CASL2のアセンブラは`DC Ltmp, 1`のように主記憶上に定数1を持つ領域を確保し，`ADD GR1, Ltmp`のようにレジスタと主記憶の演算命令を生成します．

したがってこの評価方法では，即値の演算命令は主記憶を参照する演算命令と同様にコスト3(2語命令のフェッチ+主記憶の参照)となります．

### 今回の課題にこの評価方法は妥当なのか？
このモデルはCISCプロセッサのためのものです(教科書ではMC680x0というプロセッサの機械語を目的言語としている)．
RISCのパイプラインプロセッサであれば，実行された命令数で評価する方が妥当ということになります．

このように，目的機械のモデルというのは目的機械の実装を元に決めるべきものですが，COMET2は仮想機械なのでそれができません．
ここでは，レジスタとメモリの演算命令があることなどを勘案し，実計算機としてのCOMET2について以下のような仮定を置き，教科書のモデルを採用しました．

- マルチサイクルプロセッサである
- 主記憶にアクセスする時間に比べて，レジスタ同士の演算にかかる時間は十分短い

## 使い方
`-c`オプションをつけて実行する．

## ライセンス
**JCasl2 & JComet2**はGPL2に基づくフリーソフトウェアとして公開しています．

## 参考文献
[1] 辻野嘉宏『コンパイラ』第2版，オーム社，2019年